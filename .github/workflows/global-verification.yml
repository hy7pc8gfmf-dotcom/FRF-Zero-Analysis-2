name: FRF 2.0 全局形式化验证
on:
  push:
    branches: [ main, master, release/final ]
    paths: [ '**.v', 'CoqProject', 'Makefile', 'validate.sh' ]
  pull_request:
    branches: [ main, master ]
  schedule:
    - cron: '0 2 * * 0'
  workflow_dispatch:
jobs:
  global-formal-verification:
    runs-on: ubuntu-latest
    container:
      image: coqorg/coq:8.18.0
      options: --user root
    timeout-minutes: 180
    env:
      MATHCOMP_VERSION: "1.18.0"
      COQ_VERSION: "8.18.0"
      COQ_EXTRA_OPAM: "coq-bignums"
      COQPATH: "${{ github.workspace }}/theories:${{ github.workspace }}/lib:${{ github.workspace }}/extensions"
      GLOBAL_TARGET: "all"
      REPORT_DIR: "${{ github.workspace }}/verification-reports"
      TEMP_DIR: "/__w/_temp/_runner_file_commands"
      OPAM_MAIN_MIRROR: "https://mirrors.tuna.tsinghua.edu.cn/opam-repository/"
      COQ_MAIN_MIRROR: "https://mirrors.tuna.tsinghua.edu.cn/coq-opam/released/"
      OPAM_FALLBACK_MIRROR: "https://opam.ocaml.org/"
      COQ_FALLBACK_MIRROR: "https://coq.inria.fr/opam/released/"
      VENV_PATH: "${{ github.workspace }}/.venv"
    steps:
      - name: 修复临时目录权限
        run: |
          mkdir -p ${{ env.TEMP_DIR }} ~/.opam ~/.cache/opam
          chmod -R 777 /__w/_temp/ ~/.opam ~/.cache/opam
      - name: 检出代码仓库
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          submodules: 'recursive'
      - name: 修复工作目录权限+初始化opam环境
        run: |
          mkdir -p ${{ github.workspace }}
          chmod -R 777 ${{ github.workspace }}
          opam init --disable-sandboxing -y --no-setup --reinit
          eval $(opam env --switch=default)
      - name: 缓存优化
        uses: actions/cache@v3
        with:
          path: |
            ~/.opam
            ~/.cache/opam
            _build
            **/*.vo
            **/*.glob
            ${{ env.VENV_PATH }}
          key: ${{ runner.os }}-coq-${{ env.COQ_VERSION }}-mathcomp-${{ env.MATHCOMP_VERSION }}-venv-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-coq-${{ env.COQ_VERSION }}-mathcomp-${{ env.MATHCOMP_VERSION }}-venv-
            ${{ runner.os }}-coq-${{ env.COQ_VERSION }}-venv-
      - name: 配置镜像源+安装依赖
        shell: bash
        working-directory: ${{ github.workspace }}
        run: |
          eval $(opam env --switch=default)
          opam repo list --all-switches
          if curl --head --silent --fail ${{ env.OPAM_MAIN_MIRROR }}index.tar.gz > /dev/null; then
            opam repository set-url default ${{ env.OPAM_MAIN_MIRROR }} --all-switches || {
              opam repo remove default --all-switches || true
              opam repo add default ${{ env.OPAM_MAIN_MIRROR }} --all-switches
            }
          else
            opam repository set-url default ${{ env.OPAM_FALLBACK_MIRROR }} --all-switches || {
              opam repo remove default --all-switches || true
              opam repo add default ${{ env.OPAM_FALLBACK_MIRROR }} --all-switches
            }
          fi
          if curl --head --silent --fail ${{ env.COQ_MAIN_MIRROR }}index.tar.gz > /dev/null; then
            if opam repo list | grep -q "coq-released"; then
              opam repository set-url coq-released ${{ env.COQ_MAIN_MIRROR }} --all-switches
            else
              opam repo add coq-released ${{ env.COQ_MAIN_MIRROR }} --all-switches
            fi
          else
            if opam repo list | grep -q "coq-released"; then
              opam repository set-url coq-released ${{ env.COQ_FALLBACK_MIRROR }} --all-switches
            else
              opam repo add coq-released ${{ env.COQ_FALLBACK_MIRROR }} --all-switches
            fi
          fi
          update_success=0
          for i in {1..3}; do
            if opam update -y; then
              update_success=1
              break
            fi
            sleep 2
          done
          if [ $update_success -eq 0 ]; then
            opam repository set-url default ${{ env.OPAM_FALLBACK_MIRROR }} --all-switches
            opam repository set-url coq-released ${{ env.COQ_FALLBACK_MIRROR }} --all-switches
            for i in {1..3}; do
              if opam update -y; then
                update_success=1
                break
              fi
              sleep 2
            done
          fi
          if [ $update_success -eq 0 ]; then
            exit 1
          fi
          installed_pkgs=$(opam list --short)
          required_pkgs=(
            "coq=${{ env.COQ_VERSION }}"
            "coq-stdlib=${{ env.COQ_VERSION }}"
            "coq-mathcomp-ssreflect=${{ env.MATHCOMP_VERSION }}"
            "coq-mathcomp-fingroup=${{ env.MATHCOMP_VERSION }}"
            "coq-mathcomp-algebra=${{ env.MATHCOMP_VERSION }}"
            "coq-mathcomp-solvable=${{ env.MATHCOMP_VERSION }}"
            "coq-equations=1.3+8.18"
            "${{ env.COQ_EXTRA_OPAM }}"
          )
          to_install=()
          for pkg in "${required_pkgs[@]}"; do
            pkg_name=$(echo "$pkg" | cut -d'=' -f1)
            if ! echo "$installed_pkgs" | grep -q "^$pkg_name$"; then
              to_install+=("$pkg")
            fi
          done
          if [ ${#to_install[@]} -gt 0 ]; then
            install_success=0
            for i in {1..3}; do
              if opam install -y --jobs 2 "${to_install[@]}"; then
                install_success=1
                break
              fi
              sleep 5
            done
            if [ $install_success -eq 0 ]; then
              exit 1
            fi
          fi
          eval $(opam env --switch=default)
          apt-get update && apt-get install -y --no-install-recommends python3-pip python3-venv && rm -rf /var/lib/apt/lists/*
          python3 -m venv ${{ env.VENV_PATH }}
          source ${{ env.VENV_PATH }}/bin/activate
          pip install --no-cache-dir --timeout 60 reportlab==4.0.9
          if ! command -v coqc &> /dev/null; then
            exit 1
          fi
          if ! coqc --version | grep -q "${{ env.COQ_VERSION }}"; then
            exit 1
          fi
          if ! opam list | grep -q "coq-mathcomp-ssreflect.*${{ env.MATHCOMP_VERSION }}"; then
            exit 1
          fi
          if ! command -v python &> /dev/null; then
            exit 1
          fi
      - name: 修复CoqProject文件
        shell: bash
        working-directory: ${{ github.workspace }}
        run: |
          if [ -f "CoqProject" ]; then
            echo "原始CoqProject文件内容："
            cat CoqProject
            echo "修复CoqProject文件中的无效选项..."
            grep -v -E "^(coq=8\.[0-9]+\.[0-9]+|coq=8\.[0-9]+)$" CoqProject > CoqProject.fixed
            if ! grep -q "\-R" CoqProject.fixed; then
              echo "添加必要的路径设置..."
              echo "-R theories FRF" >> CoqProject.fixed
              echo "-R lib Lib" >> CoqProject.fixed  
              echo "-R extensions Extensions" >> CoqProject.fixed
            fi
            mv CoqProject.fixed CoqProject
            echo "修复后的CoqProject文件内容："
            cat CoqProject
          else
            echo "创建基本CoqProject文件..."
            cat > CoqProject << 'EOF'
-R theories FRF
-R lib Lib
-R extensions Extensions
EOF
            find theories lib extensions -name "*.v" >> CoqProject
          fi
      - name: 生成全局验证Makefile
        shell: bash
        working-directory: ${{ github.workspace }}
        run: |
          eval $(opam env --switch=default)
          source ${{ env.VENV_PATH }}/bin/activate
          if [ ! -f "CoqProject" ]; then
            echo "错误：未找到CoqProject文件"
            exit 1
          fi
          echo "最终CoqProject文件内容："
          cat CoqProject
          echo "开始生成Makefile..."
          cp CoqProject CoqProject.backup
          echo "尝试使用coq_makefile生成Makefile..."
          if coq_makefile -f CoqProject -o Makefile 2>&1 | tee makefile_gen.log; then
            echo "✅ coq_makefile成功生成Makefile"
          else
            echo "coq_makefile失败，分析原因..."
            if grep -q "Unknown option" makefile_gen.log; then
              echo "检测到未知选项错误，清理CoqProject..."
              grep -v -E "^(coq=|mathcomp=|-\w+=\w+)" CoqProject.backup > CoqProject.clean
              if ! grep -q "\-R theories" CoqProject.clean; then
                echo "-R theories FRF" >> CoqProject.clean
              fi
              if ! grep -q "\-R lib" CoqProject.clean; then
                echo "-R lib Lib" >> CoqProject.clean
              fi
              if ! grep -q "\-R extensions" CoqProject.clean; then
                echo "-R extensions Extensions" >> CoqProject.clean
              fi
              mv CoqProject.clean CoqProject
              echo "重新尝试coq_makefile..."
              if coq_makefile -f CoqProject -o Makefile; then
                echo "✅ 清理后coq_makefile成功"
              else
                echo "创建备用Makefile..."
                cat > Makefile << 'MAKEFILE_EOF'
# 备用Makefile for FRF 2.0 全局验证
COQC := coqc
COQDOC := coqdoc
COQDEBUG := coqchk

COQFLAGS := -R theories FRF -R lib Lib -R extensions Extensions \
            -w -notation-overridden,-redundant-canonical-projection,-unused-intro-pattern,-deprecated \
            -native-compiler yes \
            -q \
            -async-proofs on

VFILES := $(shell find theories lib extensions -name "*.v")
VOFILES := $(VFILES:.v=.vo)
GLOBFILES := $(VFILES:.v=.glob)

all: $(VOFILES)

%.vo: %.v
	$(COQC) $(COQFLAGS) $<

clean:
	rm -f $(VOFILES) $(GLOBFILES)

validate: all
	$(COQDEBUG) -silent -norecursive $(VOFILES)

.PHONY: all clean validate
MAKEFILE_EOF
                echo "备用Makefile创建完成"
              fi
            else
              echo "创建备用Makefile..."
              cat > Makefile << 'MAKEFILE_EOF'
# 备用Makefile for FRF 2.0 全局验证
COQC := coqc
COQDOC := coqdoc
COQDEBUG := coqchk

COQFLAGS := -R theories FRF -R lib Lib -R extensions Extensions \
            -w -notation-overridden,-redundant-canonical-projection,-unused-intro-pattern,-deprecated \
            -native-compiler yes \
            -q \
            -async-proofs on

VFILES := $(shell find theories lib extensions -name "*.v")
VOFILES := $(VFILES:.v=.vo)
GLOBFILES := $(VFILES:.v=.glob)

all: $(VOFILES)

%.vo: %.v
	$(COQC) $(COQFLAGS) $<

clean:
	rm -f $(VOFILES) $(GLOBFILES)

validate: all
	$(COQDEBUG) -silent -norecursive $(VOFILES)

.PHONY: all clean validate
MAKEFILE_EOF
              echo "备用Makefile创建完成"
            fi
          fi
          if [ -f "Makefile" ]; then
            echo "Makefile生成成功"
            echo "验证Makefile基本结构..."
            if grep -q "all:" Makefile && grep -q "%.vo:" Makefile; then
              echo "✅ Makefile结构完整"
            else
              echo "❌ Makefile结构不完整"
              exit 1
            fi
          else
            echo "错误：Makefile生成失败"
            exit 1
          fi
      - name: 执行全局形式化验证
        shell: bash
        working-directory: ${{ github.workspace }}
        run: |
          eval $(opam env --switch=default)
          source ${{ env.VENV_PATH }}/bin/activate
          mkdir -p ${{ env.REPORT_DIR }}
          echo "开始并行编译验证..."
          echo "可用Makefile目标："
          make -n | head -20
          if make -j$(nproc) 2>&1 | tee ${{ env.REPORT_DIR }}/global-compile.log; then
            echo "✅ 编译成功完成"
          else
            echo "编译失败，尝试单线程编译..."
            if make 2>&1 | tee ${{ env.REPORT_DIR }}/global-compile-single.log; then
              echo "✅ 单线程编译成功"
            else
              echo "❌ 编译完全失败"
              echo "前20个错误："
              grep -i error ${{ env.REPORT_DIR }}/global-compile-single.log | head -20
              exit 1
            fi
          fi
          echo "检查编译产物..."
          vfiles_count=$(find theories lib extensions -name "*.v" | wc -l)
          vofiles_count=$(find theories lib extensions -name "*.vo" | wc -l)
          echo "源文件数: $vfiles_count, 编译文件数: $vofiles_count"
          if [ $vfiles_count -gt 0 ] && [ $vofiles_count -eq $vfiles_count ]; then
            echo "✅ 所有文件编译成功"
          elif [ $vofiles_count -gt 0 ]; then
            echo "⚠️  部分文件编译成功 ($vofiles_count/$vfiles_count)"
          else
            echo "❌ 没有文件编译成功"
            exit 1
          fi
      - name: 全局逻辑一致性校验
        shell: bash
        working-directory: ${{ github.workspace }}
        run: |
          eval $(opam env --switch=default)
          source ${{ env.VENV_PATH }}/bin/activate
          echo "开始逻辑一致性检查..."
          vo_files=$(find theories/ lib/ extensions/ -name "*.vo")
          if [ -z "$vo_files" ]; then
            echo "❌ 未找到编译产物，跳过逻辑一致性检查"
            exit 1
          fi
          echo "检查 $(echo "$vo_files" | wc -l) 个编译文件..."
          if coqchk -silent -norecursive $vo_files 2>&1 | tee ${{ env.REPORT_DIR }}/global-coqchk.log; then
            echo "✅ 逻辑一致性检查通过"
          else
            echo "❌ 逻辑一致性检查失败"
          fi
      - name: 生成结构化验证报告
        shell: bash
        working-directory: ${{ github.workspace }}
        run: |
          eval $(opam env --switch=default)
          source ${{ env.VENV_PATH }}/bin/activate
          total_files=$(find theories lib extensions -name "*.v" | wc -l)
          compiled_files=$(find theories lib extensions -name "*.vo" | wc -l)
          coqchk_status=$([ -f "${{ env.REPORT_DIR }}/global-coqchk.log" ] && (grep -q "Error" "${{ env.REPORT_DIR }}/global-coqchk.log" && echo "失败" || echo "通过") || echo "未执行")
          cat > ${{ env.REPORT_DIR }}/SUMMARY.md << 'REPORT_EOF'
# FRF 2.0 全局形式化验证报告

## 验证概览
- **验证时间**: $(date +'%Y-%m-%d %H:%M:%S')
- **触发事件**: ${{ github.event_name }}
- **提交哈希**: ${{ github.sha }}
- **运行容器**: coqorg/coq:${{ env.COQ_VERSION }}
- **Coq版本**: $(coqc --version | head -n1)
- **MathComp版本**: ${{ env.MATHCOMP_VERSION }}
- **编译核心数**: $(nproc)

## 验证结果
- **总待验证文件数**: $total_files
- **成功验证文件数**: $compiled_files
- **验证成功率**: $((compiled_files * 100 / total_files))%
- **逻辑一致性**: $coqchk_status

## 核心模块状态
REPORT_EOF
          core_modules=(
            "theories/FRF_MetaTheory.vo:FRF_MetaTheory"
            "theories/Equivalence.vo:Equivalence" 
            "lib/Algebra.vo:Algebra"
            "extensions/Quantum/QFT_FRF.vo:QFT_FRF"
          )
          for mod_info in "${core_modules[@]}"; do
            mod_file=$(echo "$mod_info" | cut -d: -f1)
            mod_name=$(echo "$mod_info" | cut -d: -f2)
            if [ -f "$mod_file" ]; then
              echo "✅ **$mod_name**: 验证通过" >> ${{ env.REPORT_DIR }}/SUMMARY.md
            else
              echo "❌ **$mod_name**: 验证失败" >> ${{ env.REPORT_DIR }}/SUMMARY.md
            fi
          done
          echo -e "\n## 详细日志" >> ${{ env.REPORT_DIR }}/SUMMARY.md
          echo "- [编译日志](global-compile.log)" >> ${{ env.REPORT_DIR }}/SUMMARY.md
          echo "- [单线程编译日志](global-compile-single.log)" >> ${{ env.REPORT_DIR }}/SUMMARY.md
          echo "- [逻辑一致性检查日志](global-coqchk.log)" >> ${{ env.REPORT_DIR }}/SUMMARY.md
          echo "✅ 验证报告生成完成"
      - name: 归档验证产物与报告
        uses: actions/upload-artifact@v4
        with:
          name: frf-2.0-verification-results-${{ github.sha }}
          path: |
            ${{ env.REPORT_DIR }}/**/*
            **/*.vo
            **/*.glob
            Makefile
            CoqProject
            ${{ env.VENV_PATH }}/lib/python*/site-packages/*.dist-info
          retention-days: 90
      - name: 验证失败紧急通知
        if: failure()
        run: |
          echo "❌ FRF 2.0 全局形式化验证失败"
          echo "请检查编译日志和逻辑一致性检查日志以获取详细信息"
