name: FRF 2.0 全量形式化验证（完整版）

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:

jobs:
  formal-verification:
    runs-on: ubuntu-22.04
    timeout-minutes: 240  # 增加总超时时间到240分钟
    
    steps:
    - name: 📥 检出代码仓库
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        submodules: false

    - name: 🖥️ 系统信息检查
      run: |
        echo "=== 系统信息 ==="
        echo "系统: $(uname -a)"
        echo "CPU核心: $(nproc)"
        echo "内存: $(free -m | awk '/^Mem:/{print "总量:" $2 "MB, 可用:" $7 "MB"}')"
        echo "磁盘:"
        df -h

    - name: 📦 安装系统依赖（精简版）
      run: |
        echo "安装系统依赖..."
        sudo apt-get update
        sudo apt-get install -y \
          opam \
          bubblewrap \
          g++ \
          pkg-config \
          m4 \
          rsync \
          git \
          wget \
          bc  # 添加bc用于计算
        echo "✅ 系统依赖安装完成"

    - name: 🔄 初始化OPAM环境（基于可执行版）
      timeout-minutes: 20
      run: |
        echo "初始化OPAM环境..."
        opam init --disable-sandboxing -y --compiler=4.14.0
        eval $(opam env)
        opam repo add coq-released https://coq.inria.fr/opam/released
        opam update
        echo "✅ OPAM环境初始化完成"
        echo "OPAM版本: $(opam --version)"

    - name: 📚 安装Coq核心（固定版本）
      timeout-minutes: 25
      run: |
        eval $(opam env)
        echo "安装Coq 8.18.0..."
        
        # 安装Coq核心（不安装推荐包）
        opam install -y --no-depexts coq.8.18.0
        
        echo "验证Coq安装..."
        if coqc --version | grep -q "8.18.0"; then
          echo "✅ Coq 8.18.0 安装成功"
        else
          echo "❌ Coq版本不匹配"
          exit 1
        fi

    - name: 🧮 安装mathcomp-ssreflect（精确版本1.17.0）
      timeout-minutes: 15
      run: |
        eval $(opam env)
        echo "安装mathcomp-ssreflect 1.17.0..."
        
        # 精确安装指定版本，避免自动升级
        opam install -y --no-depexts coq-mathcomp-ssreflect=1.17.0
        
        echo "验证mathcomp安装..."
        if opam list --installed | grep -q "coq-mathcomp-ssreflect.1.17.0"; then
          echo "✅ mathcomp-ssreflect 1.17.0 安装成功"
        else
          echo "❌ mathcomp安装失败"
          echo "当前安装的mathcomp版本:"
          opam list --installed | grep mathcomp
          exit 1
        fi

    - name: 📊 环境验证报告
      run: |
        eval $(opam env)
        echo "=== 环境验证报告 ==="
        echo "Coq版本:"
        coqc --version
        echo ""
        echo "核心包列表:"
        opam list --installed --short | grep -E "coq|mathcomp"
        echo ""
        echo "环境变量:"
        echo "OPAMROOT: $OPAMROOT"
        echo "OPAMSWITCH: $OPAMSWITCH"

    - name: 📁 扫描项目结构
      run: |
        echo "=== 扫描项目结构 ==="
        echo "项目根目录结构:"
        ls -la
        
        echo ""
        echo "扫描所有.v文件:"
        find . -name "*.v" -type f | grep -v ".git" | sort
        
        echo ""
        echo "统计各目录文件数:"
        for dir in SelfContainedLib theories Quantum CS_Null Test; do
          if [ -d "$dir" ]; then
            count=$(find "$dir" -name "*.v" -type f | wc -l)
            echo "$dir: $count 个.v文件"
          fi
        done

    - name: 🔧 构建Makefile兼容环境
      run: |
        echo "创建编译环境配置..."
        
        # 创建简化的编译脚本
        cat > compile_all.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "=== FRF 2.0 全量编译开始 ==="
        echo "开始时间: $(date)"
        
        # 基础编译标志
        BASE_FLAGS="-Q SelfContainedLib SelfContainedLib -Q theories FRF.Theories -Q Quantum FRF.Quantum -Q CS_Null FRF.CS_Null -Q Test FRF.Test"
        
        # 函数：编译单个文件
        compile_file() {
          local file="$1"
          local dir="$(dirname "$file")"
          local base="$(basename "$file" .v)"
          
          echo "编译: $file"
          
          # 使用统一的编译参数，不对大文件特殊处理
          if coqc $BASE_FLAGS "$file"; then
            echo "✅ $base.v 编译成功"
            return 0
          else
            echo "❌ $base.v 编译失败"
            return 1
          fi
        }
        
        # 函数：编译目录中的所有文件
        compile_dir() {
          local dir="$1"
          local pattern="${2:-*.v}"
          
          if [ ! -d "$dir" ]; then
            echo "目录不存在: $dir"
            return 0
          fi
          
          echo "扫描目录: $dir"
          local files=$(find "$dir" -name "$pattern" -type f | sort)
          local count=$(echo "$files" | wc -w)
          
          if [ $count -eq 0 ]; then
            echo "  无$pattern文件"
            return 0
          fi
          
          echo "  找到 $count 个文件"
          
          for file in $files; do
            compile_file "$file"
          done
        }
        
        # 按照依赖顺序编译
        echo ""
        echo "阶段1: 编译自包含基础库"
        compile_dir "SelfContainedLib"
        
        echo ""
        echo "阶段2: 编译FRF元理论"
        compile_dir "theories" "FRF_MetaTheory.v"
        compile_dir "theories" "Church*.v"
        
        echo ""
        echo "阶段3: 编译数学场景"
        compile_dir "theories" "Case*.v"
        
        echo ""
        echo "阶段4: 编译量子模块"
        compile_dir "Quantum"
        
        echo ""
        echo "阶段5: 编译空值系统"
        compile_dir "CS_Null"
        
        echo ""
        echo "阶段6: 编译集成模块"
        compile_dir "theories" "FRF_Comparative.v"
        
        echo ""
        echo "阶段7: 编译测试套件"
        compile_dir "Test"
        
        echo ""
        echo "=== FRF 2.0 全量编译完成 ==="
        echo "完成时间: $(date)"
        EOF
        
        chmod +x compile_all.sh
        echo "✅ 编译脚本创建完成"

    - name: 🔧 执行全量编译
      timeout-minutes: 180  # 单独给编译步骤180分钟
      run: |
        eval $(opam env)
        echo "开始全量编译..."
        
        # 执行编译脚本
        ./compile_all.sh
        
        echo "✅ 全量编译执行完成"

    - name: 🔧 编译特定大文件（备用方案）
      if: failure()  # 如果上面的编译失败，尝试这个备用方案
      timeout-minutes: 60
      run: |
        eval $(opam env)
        echo "尝试备用编译方案..."
        
        # 基础编译标志
        BASE_FLAGS="-Q SelfContainedLib SelfContainedLib -Q theories FRF.Theories -Q Quantum FRF.Quantum -Q CS_Null FRF.CS_Null -Q Test FRF.Test"
        
        # 手动编译已知的大文件（简化参数）
        BIG_FILES=(
          "SelfContainedLib/Geometry.v"
          "theories/FRF_MetaTheory.v"
          "theories/ChurchNumerals.v"
          "theories/CaseE_QuantumVacuum.v"
          "CS_Null/FRF_CS_Null_Common.v"
          "theories/FRF_Comparative.v"
        )
        
        echo "编译已知大文件..."
        for file in "${BIG_FILES[@]}"; do
          if [ -f "$file" ]; then
            echo "编译大文件: $(basename "$file")"
            # 使用最简单的参数，避免复杂配置
            coqc $BASE_FLAGS -m 8192 "$file" && echo "✅ 编译成功" || echo "❌ 编译失败"
          fi
        done

    - name: 📊 全量编译结果统计
      run: |
        eval $(opam env)
        echo "=== 全量编译结果统计 ==="
        
        # 定义所有已知模块（基于全局视角文档）
        KNOWN_MODULES=(
          # 层级1: 自包含基础库
          "SelfContainedLib/Algebra"
          "SelfContainedLib/Category"
          "SelfContainedLib/Geometry"
          
          # 层级2: FRF元理论
          "theories/FRF_MetaTheory"
          "theories/ChurchZero"
          "theories/ChurchNumerals"
          
          # 层级3: 数学场景
          "theories/CaseA_SetTheory"
          "theories/CaseB_Algebra"
          "theories/CaseC_TypeTheory"
          "theories/CaseD_CategoryTheory"
          "theories/CaseE_QuantumVacuum"
          
          # 层级4: 量子模块
          "Quantum/QFT_FRF"
          "Quantum/CurvedSpacetimeQFT"
          
          # 层级4: 空值系统
          "CS_Null/FRF_CS_Null_Common"
          "CS_Null/FRF_CS_Null"
          "CS_Null/CxxNull"
          "CS_Null/PythonNull"
          "CS_Null/JavaNull"
          "CS_Null/MathNull"
          "CS_Null/RustNull"
          
          # 层级5: 集成模块
          "theories/FRF_Comparative"
          
          # 层级6: 测试套件
          "Test/Test_Basic"
          "Test/Test_FRF_MetaTheory"
          "Test/Test_QuantumVacuum"
          "Test/Test_BlockchainSystem"
          "Test/SelfContainedVerification"
        )
        
        # 自动发现新增模块
        echo "扫描新增模块..."
        ALL_FILES=$(find . -name "*.v" -type f | grep -v ".git" | sed 's/\.v$//' | sort)
        
        echo ""
        echo "模块编译状态:"
        echo "=================="
        
        total_modules=0
        success_modules=0
        missing_modules=0
        
        # 检查已知模块
        for module in "${KNOWN_MODULES[@]}"; do
          total_modules=$((total_modules + 1))
          
          if [ -f "${module}.vo" ]; then
            size=$(stat -c%s "${module}.vo" 2>/dev/null || echo 0)
            echo "✅ $(basename "$module") (大小: ${size} bytes)"
            success_modules=$((success_modules + 1))
          else
            echo "❌ $(basename "$module") (未找到.vo文件)"
            missing_modules=$((missing_modules + 1))
          fi
        done
        
        # 检查自动发现的新模块
        echo ""
        echo "自动发现的新模块:"
        echo "=================="
        
        for file in $ALL_FILES; do
          # 检查是否已经在已知模块中
          found=0
          for known in "${KNOWN_MODULES[@]}"; do
            if [ "$file" = "$known" ]; then
              found=1
              break
            fi
          done
          
          if [ $found -eq 0 ]; then
            total_modules=$((total_modules + 1))
            
            if [ -f "${file}.vo" ]; then
              size=$(stat -c%s "${file}.vo" 2>/dev/null || echo 0)
              echo "✅ 新增: $(basename "$file") (大小: ${size} bytes)"
              success_modules=$((success_modules + 1))
            else
              echo "⚠️  新增: $(basename "$file") (未编译)"
              missing_modules=$((missing_modules + 1))
            fi
          fi
        done
        
        echo ""
        echo "📊 统计摘要:"
        echo "总模块数: $total_modules"
        echo "成功编译: $success_modules"
        echo "未编译/缺失: $missing_modules"
        
        if [ $missing_modules -eq 0 ]; then
          echo "🎉 所有模块编译成功!"
        elif [ $success_modules -gt 0 ]; then
          success_rate=$((success_modules * 100 / total_modules))
          echo "📈 编译成功率: ${success_rate}%"
        else
          echo "❌ 编译失败"
          exit 1
        fi
        
        # 列出所有生成的.vo文件
        echo ""
        echo "📁 所有生成的.vo文件:"
        find . -name "*.vo" -type f 2>/dev/null | while read file; do
          size=$(stat -c%s "$file" 2>/dev/null || echo 0)
          echo "  📄 $file (${size} bytes)"
        done | head -20  # 只显示前20个，避免输出太长

    - name: 📄 生成全量验证报告
      run: |
        echo "生成全量验证报告..."
        
        # 创建报告目录
        mkdir -p verification-reports
        
        # 获取环境信息
        COQ_VERSION=$(coqc --version 2>/dev/null | head -1 || echo "未知")
        OPAM_VERSION=$(opam --version 2>/dev/null || echo "未知")
        
        # 统计所有.vo文件
        VO_COUNT=$(find . -name "*.vo" -type f 2>/dev/null | wc -l)
        VO_FILES=$(find . -name "*.vo" -type f 2>/dev/null | xargs -I {} basename {} .vo | tr '\n' ', ' | sed 's/, $//')
        
        # 生成报告
        cat > verification-reports/FRF_FULL_VERIFICATION_REPORT.md << EOF
# FRF 2.0 全量形式化验证报告

## 验证概述
- **验证时间**: $(date)
- **运行环境**: GitHub Actions (Ubuntu 22.04)
- **Coq版本**: $COQ_VERSION
- **OPAM版本**: $OPAM_VERSION
- **总超时时间**: 240分钟
- **编译策略**: 统一参数，无大文件特殊处理

## 编译结果统计
- **总模块数**: $(find . -name "*.v" -type f 2>/dev/null | wc -l)
- **成功编译**: $VO_COUNT
- **编译成功率**: $((VO_COUNT * 100 / $(find . -name "*.v" -type f 2>/dev/null | wc -l) 2>/dev/null || echo 0))%

## 已编译模块
$VO_FILES

## 验证状态
$(if [ $VO_COUNT -gt 20 ]; then echo "✅ **验证通过** - 成功编译 $VO_COUNT 个模块"; else echo "❌ **验证未通过** - 仅编译 $VO_COUNT 个模块"; fi)

## 环境依赖信息
\`\`\`bash
$(opam list --installed 2>/dev/null | grep -E "coq|mathcomp" || echo "依赖信息获取成功")
\`\`\`

## 文件结构
\`\`\`
$(find . -name "*.v" -type f 2>/dev/null | sort | sed 's/^/  /')
\`\`\`

## 后续步骤
1. 检查未编译模块的原因
2. 验证核心定理是否通过
3. 生成形式化验证报告
EOF
        
        echo "✅ 验证报告生成完成"

    - name: 📤 上传验证报告
      uses: actions/upload-artifact@v4
      with:
        name: frf-2.0-full-verification-report
        path: verification-reports/
        retention-days: 30

    - name: 📤 上传编译产物
      if: always()  # 无论成功失败都上传
      uses: actions/upload-artifact@v4
      with:
        name: frf-2.0-compiled-modules
        path: |
          SelfContainedLib/*.vo
          theories/*.vo
          Quantum/*.vo
          CS_Null/*.vo
          Test/*.vo
        retention-days: 30

    - name: 🎉 验证成功通知
      if: success()
      run: |
        VO_COUNT=$(find . -name "*.vo" -type f 2>/dev/null | wc -l)
        echo "🎉🎉🎉 FRF 2.0 全量形式化验证成功！"
        echo "========================================="
        echo "✅ 成功编译模块数: $VO_COUNT"
        echo "✅ 包含自包含基础库 + FRF元理论 + 数学场景"
        echo "✅ 包含量子模块 + 空值系统 + 集成模块 + 测试套件"
        echo "✅ 全链路形式化验证完成"
        echo "📊 验证报告已生成并保存"
        echo "📦 编译产物已上传"
        echo "🕒 完成时间: $(date)"
        echo "========================================="

    - name: ⚠️ 验证失败通知
      if: failure()
      run: |
        VO_COUNT=$(find . -name "*.vo" -type f 2>/dev/null | wc -l)
        echo "⚠️⚠️⚠️ FRF 2.0 全量形式化验证未完全成功"
        echo "========================================="
        echo "❌ 成功编译模块数: $VO_COUNT"
        echo "❌ 部分模块编译失败"
        echo "📊 验证报告已生成"
        echo "📦 编译产物已上传（部分）"
        echo "🕒 失败时间: $(date)"
        echo "========================================="
        echo ""
        echo "建议检查："
        echo "1. 查看编译日志中的具体错误"
        echo "2. 检查模块依赖关系"
        echo "3. 验证环境配置是否正确"
        echo "4. 考虑增加内存或超时时间"